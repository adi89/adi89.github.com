{"name":"AdiSingh blog ya'll","tagline":"","body":"\r\n##Datalocking in Rails  // 2-7-15\r\n\r\n\r\nI've been going over Rails 4 guide by Obie Fernandez, and I'm really trying to bring to light things that I've overlooked with ActiveRecord. I frequently have my go-to's, but I really want a thorough understanding of everything there is to offer. \r\n\r\nA cool concept I learned today through this book as well as [this video](https://www.youtube.com/watch?v=bGRsGUKs28o) was the concept of Data locking.\r\n\r\nSo let's get into it..\r\n\r\n**What is Datalocking?**\r\n\r\nDatalocking is a term to describe techniques that prevent multiple concurrent users of an app from updating + overwriting a record. Matt accesses the venue page and wants to change a detail. Sean does the same. And it's 9:45pm. Say Matt updates the page before Sean. Datalocking will prevent Sean from overwriting the venue page. \r\n\r\nThere's two types of Datalocking supported by ActiveRecord: optimistic and pessimistic. \r\n\r\n###Look on the bright side\r\n\r\nOptimistic Loading  resolve collision _if_ they occur. What I mean by that is that the locking mechanism is occuring provided something triggers it.\r\n\r\n    class AddLockVersionToVenues < ActiveRecord::Migration\r\n     def change\r\n      add_column :venues, :lock_version, :integer, default:0\r\n     end\r\n\r\n    end\r\n\r\nYou add the lock version column to the table you want optimistic loading on. Think of the _lock_version_ property of the version of the record you have. Each time you update the Bada-Bing (Sopranos reference ahem) record, the lock_version will increment.\r\n\r\nBack to our favorite buffoons. So let's say two concurrent users loaded up that record. Each of them are on the edit page and want to make an update. But John made it first, the _lock_version_ will increment. Now the record has been updated in the database, with a +1 _lock_version_ \r\n\r\nBut then where does that leave Sean ? He's clinging onto a Stale object. If he tries to update the _Bada Bing_ , then a ActiveRecord::StaleObjectError shall be raised. \r\n\r\nThe way to deal with this when using optimistic loading is to have a rescue statement in the controller. \r\n\r\nA couple things to note here:\r\n* very little modification has to be made to implement this feature\r\n* update operation is slower since _lock_version_ has to be checked. \r\n* like above, it sucks for the user who spent time inputting all this crap to realize that the Bing was modified by  Mike and Sean was making changes. \r\n\r\n###Glass half empty\r\n\r\nOr is it?  You don't have to modify your table at all. Here, you're taking advantage of the Database's built-in locking and transaction mechanisms.\r\n\r\nTransactions exist so you can sync up multiple database operations in a single 'all or nothing' operation. Whatever is within the transaction block is not visible to the outside, and ALL the changes take effect at the completion of the block. \r\n\r\nJacking this example from railsguides:\r\n\r\n    Account.transaction do\r\n     # select * from accounts where name = 'shugo' limit 1 for update\r\n     shugo = Account.where(\"name = 'shugo'\").lock(true).first\r\n     yuko = Account.where(\"name = 'yuko'\").lock(true).first\r\n     shugo.balance -= 100\r\n     shugo.save!\r\n     yuko.balance += 100\r\n     yuko.save!\r\n    end\r\n\r\nWhat anime did they find these names? Anyway, the rows returned by the SQL query (in this case a AR method that's distilled down to it's corresponding query) will be locked. Upon completion of the transaction, the locked state of the record will end. \r\n\r\nTo note\r\n* super easy to implement\r\n* keep transactions small to avoid extended processing time that where one rails process waiting on another. (rails processes often single threaded)\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}